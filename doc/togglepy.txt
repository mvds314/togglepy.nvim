===============================================================================
togglepy.nvim - A plugin for toggling Python debugging and REPLs
===============================================================================

1. Introduction *togglepy-intro* 

togglepy.nvim is a Neovim plugin that provides a REPL based workflow for
Python, similar to what you encounter in the scientitic programming development
environments of MATLAB, R, and Python's Spyder IDE.

This plugin allows you to:
* Open an ipython REPL within Neovim (based on toggleterm.nvim) and easily
  switch to it.
* Send lines or visual selections to the REPL.
* Debug Python code with ipdb/pdb in the REPL.
* Keep track of the debugging session in Neovim
  (using nvim-dap.nvim, nvim-dap-ui.nvim, and the ipdab python package).
* Switch between virtual environments (using telescope.nvim).

A main part of the workflow is toggling the REPL with <C-\> using
toggleterm.nvim. Hence the name togglepy.nvim.

2. Why? *togglepy-why*

Python is ideal if you want to do scientific programming with well structured
code. It is interpreted like MATLAB and R. But, at the same time, it can be more
than just another scripting language. Its advanced programming features, such
as classes, modules and unit testing, are not just add-ons, but are core parts
of the language.

Neovim has great support for the development workflow of compiled languages
like C, C++, and Java. Problems start, however, when you start to apply those
workflows to scientific programming with Python. For example, say you create a
function or method that plots some data, and you don't like the way it looks.
What you want to do is debug with an interactive REPL inside the function where
you make the plot, change some code, and send it to the REPL until the plot
looks the way you want. The same holds for inspecting data structures. Of
course, you can set watches, this is all you can do in compiled languages. But
with Python you can interact with everything live.

The bottom line is, make use of the REPL, and make it an integral part of your
development workflow. This is what togglepy.nvim is all about.

3. Setup                                            *togglepy-setup*

Prerequisites:
* Python with `ipython`, and `ipdab` pacakges installed. 
* Neovim with the following plugins:
  - nvim-telescope/telescope.nvim
  - nvim-lua/plenary.nvim
  - nvim-treesitter/nvim-treesitter
  - akinsho/toggleterm.nvim
  - mfussenegger/nvim-dap
  - rcarriga/nvim-dap-ui
    
Set up with Lazy.nvim as follows
>
 require("lazy").setup({
  'user/togglepy.nvim',
   requires = {'nvim-telescope/telescope.nvim',
               'nvim-lua/plenary.nvim',
               'nvim-treesitter/nvim-treesitter',
               'akinsho/toggleterm.nvim',
               'mfussenegger/nvim-dap',
               'rcarriga/nvim-dap-ui',},
   config = function()
                -- TODO: add configuration options
                local opts = {host="localhost", port=9000}
                local opts = { ipdab = { host = "localhost", port = 9000 },
                               repl = { terminal_direction = "vertical" },
                               keymaps = { window_navigation = true,
                                           send_key = "<F9>",
                                           run_key = "<F5>",
                                           next_key = "<F10>",
                                           step_in_key = "<F11>",
                                           step_out_key = "<F12>",},
                    }
                require('togglepy').setup(opts)
             end,
 })
<
The `opts` table can contain the following fields:
* 'ipdab': A table with options for the ipdab DAP server. It can contain the
  following fields:
  - `host`: An ip address where the DAP server should listen. Default is
    `"localhost"`.
  - `port`: The port where the DAP server should listen. Default is `900
When empty or not passed, the default values as passed above are used.
* 'repl': A table with options for the REPL terminal. It can contain the
  following fields:
  - `terminal_direction`: Direction of the REPL terminal, either `"float"` or
    `"vertical"`. Default is `"vertical"`.
* 'keymaps': A table with keymaps for REPL and debugging. It can contain the
  following fields:
  - `window_navigation`: Whether to set up window navigation keymaps, i.e.,
    '<C-w>h/j/k/l' for terminal mode. Default is `true`.
  - `send_key`: Key to send the current line or visual selection to the REPL
    (default: `<F9>`).
  - `run_key`: Key to run the current Python file in the REPL or to
    continue in debug mode (default: `<F5>`).
  - `next_key`: Key to step over in the debugger (default: `<F10>`).
  - `step_in_key`: Key to step into in the debugger (default
    `<F11>`).
  - `step_out_key`: Key to step out/return in the debugger (default
    `<F12>`).

For best integration, set up the <C-\> key mapping to toggle the REPL 
with toggleterm. The following is an example configuration a decent
toggleterm.nvim configuration: 
>
 require("lazy").setup({
   "akinsho/toggleterm.nvim",
   lazy = true,
   opts = { size = 99,
           open_mapping = [[<c-\>]],
           hide_numbers = true,
           shade_terminals = true,
           shading_factor = 2,
           start_in_insert = false,
           insert_mappings = true,
           persist_size = true,
           direction = "float", -- Default direction for terminals },
   keys = {
     { "<C-\\>", mode = { "i", "t", "n" }, "<cmd>ToggleTerm<CR>",
       desc = "Toggle terminal" },
     { "<C-\\>", mode = "n",
       function()
         vim.cmd("ToggleTerm " .. vim.v.count1)
       end,
       desc = "Toggle terminal <count> with <count><C-\\>",
       expr = false, },
    },
    cmd = "ToggleTerm",
 })
<
4. Provided commands                                *togglepy-commands*

* `TogglePyTerminal`: Toggles the ipython REPL terminal, i.e., creates it if
  it does not exist yet, or hides/unhides it if it does.
* `:TogglePyRunFile`: Saves all buffers, changes the working directory in the repl
  to the location of the file, and runs the current Python file in the ipython
  REPL using the magic `%run -i your_script.py`.
* `:TogglePyPickEnv`: Search for Python environments on your system and uses
  telescope.nvim to pick a Python virtual environment.
* `:TogglePyClearEnvs`: Clears the list of found Python virtual environments.
* `:TogglePySwitchTerminalDirection`: Switches the direction of the
  ipython REPL terminal between `float`, and `vertical`. Requires a restart of
  the REPL.

5. How it works                                       *togglepy-how*

When you open a Python file, and use the command `:TogglePyTerminal`, a
special toggleterm terminal is created that starts `ipython` by default. This
one will be remembered by togglepy.nvim until you close its buffer, and used
for all REPL interactions. Most often, it might be the only toggleterm
terminal you use, in which case you can hide/unhide to it with `<C-\>`. Single
lines or selections can be send to the terminal with <F9>. Your file can be
executed with <F5>, which which will create terminal if it does not exist yet,
and runs your script with the ipython magic `%run -i your_script.py`.

By default the terminal will start in the Python environment as available at
the prompt where Neovim is started. You can also switch to another virtual
environment with `:TogglePyPickEnv`, which searches for Python virtual
environments on your system and allows you to pick one with telescope.nvim.

It is recommended to use the ipython REPL with the `autoreload` extension
enabled. This will basically ensure that modules are reloaded when you make
changes to them before execution. You can automate this by creating a file
`~/.ipython/profile_default/startup/mystartup.py` with the following
content:
>
 # ~/.ipython/profile_default/startup/mystartup.py
 get_ipython().run_line_magic("load_ext", "autoreload")
 get_ipython().run_line_magic("autoreload", "2")
<
There are some cases where autoreload does not work. So, unfortunately,
sometimes, you still have to restart the REPL. Although this is annoying,
currently, togglepy.nvim provides ipython as is, so this is just how it works
for now.

To get seemless debugging integration, we use the ipdab Python package, which
is a small wrapper around the standard ipdb/pdb debugger. Basically, use
`import ipdab; ipdab.set_trace()` instead of `import pdb; pdb.set_trace()`.
When you step through your code with the debugger, there will be an arrow that
keeps track of where you are in your code.

What now happens in the background is that a TCP server is started that
provides the Debug Adapter Protocol (DAP) interface. This is then used by
nvim-dap.nvim to connect to the debugging session. Unfortunately, pdb/ipdb are
blocking once you hit a breakpoint, i.e., when you see a prompt. This means
that control is given to the user or process that controls the REPL.
Therefore, the debugging session cannot be fully controlled by the DAP. The
way out with Neovim is to create keymaps <F5>, <F10>, <F11> to that send
`continue`, `next`, and `step` commands to the REPL. This works because Neovim
controls the teminal to which the debugger gives control when it is blocking.
When running your Python program in a separate terminal, outside of Neovim,
you can still connect the debugger to it, but because Neovim does not control
the terminal, you cannot send commands to it and control the debugging session
from within Neovim.









    


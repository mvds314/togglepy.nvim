===============================================================================
togglepy.nvim - A plugin for toggling Python debugging and REPLs
===============================================================================

TODO read everythign again

1. Introduction *togglepy-intro* 

togglepy.nvim is a Neovim plugin that provides a REPL based workflow, similar
to what you encounter in the scientitic programming development environments
of MATLAB, R, and Python's Spyder IDE.

This plugin allows you to:
* Open an ipython REPL within Neovim (based on toggleterm.nvim) and easily
  switch to it.
* Send lines or visual selections to the REPL.
* Debug Python code with ipdb/pdb in the REPL.
* Keep track of the debugging session in Neovim
  (using nvim-dap.nvim, nvim-dap-ui.nvim, and the ipdab python package).
* Switch between virtual environments (using telescope.nvim).

A main part of the workflow is toggling the REPL with <C-\> and
toggleterm.nvim is a major workhose under the hood, the plugin is called
togglepy.nvim.

2. Why? *togglepy-why*

Python is ideal if you want to do scientific programming with well structured
code. It is interpreted like MATLAB and R. But, at the same time, it ca be more
than just another scripting language. Its advanced programming features, such
as classes, modules and unit testing, are not just add-ons, but are core parts
of the language.

Neovim has great support for the development workflow of compiled languages
like C, C++, and Java. Problems start, however, when you start to apply those
workflows to scientific programming with Python. For example, say you create a
function or method that plots some data, and you don't like the way it looks.
What you want to do is debug with an interactive REPL inside the function
where you make the plot, change some code, send it to the REPL, until the plot
looks the way you want. The same holds for inspecting data structures. Of
course, you can set watches, this is all you can do in compiled languages. But
with Python you interact with everything live.

The bottom line is, make use of the REPL, and make it an integral part of your
development workflow. This is what togglepy.nvim is all about.

3. Setup                                            *togglepy-setup*

Prerequisites:
* Python with `ipython`, and `ipdab` pacakges installed. 
* Neovim with the following plugins:
  - nvim-telescope/telescope.nvim
  - nvim-lua/plenary.nvim
  - nvim-treesitter/nvim-treesitter
  - akinsho/toggleterm.nvim
  - mfussenegger/nvim-dap
  - rcarriga/nvim-dap-ui
    
Set up with Lazy.nvim as follows
>
 require("lazy").setup({
  'user/togglepy.nvim',
   requires = {'nvim-telescope/telescope.nvim',
               'nvim-lua/plenary.nvim',
               'nvim-treesitter/nvim-treesitter',
               'akinsho/toggleterm.nvim',
               'mfussenegger/nvim-dap',
               'rcarriga/nvim-dap-ui',},
   config = function()
                -- TODO: add configuration options
                local opts = {host="localhost", port=9000}
                require('togglepy').setup(opts)
             end,
 })
<
The `opts` table can contain the following fields:
* 'host': An ip address where the DAP server should listen. Default is
  `"localhost"`.
* 'port': The port where the DAP server should listen. Default is `9000`.
When empty or not passed, the default values as passed above are used.

For best integration, set up the <C-\> key mapping to toggle the terminal
with toggleterm. The following is an example configuration a decent
toggleterm.nvim configuration: 
>
 require("lazy").setup({
   "akinsho/toggleterm.nvim",
   lazy = true,
   opts = { size = 99,
           open_mapping = [[<c-\>]],
           hide_numbers = true,
           shade_terminals = true,
           shading_factor = 2,
           start_in_insert = false,
           insert_mappings = true,
           persist_size = true,
           direction = "float", -- Default direction for terminals },
   keys = {
     { "<C-\\>", mode = { "i", "t", "n" }, "<cmd>ToggleTerm<CR>",
       desc = "Toggle terminal" },
     { "<C-\\>", mode = "n",
       function()
         vim.cmd("ToggleTerm " .. vim.v.count1)
       end,
       desc = "Toggle terminal <count> with <count><C-\\>",
       expr = false, },
    },
    cmd = "ToggleTerm",
 })
<
4. Provided commands                                *togglepy-commands*

* `:ToggleIPythonTerm`: Creates or toggles the ipython REPL terminal. TODO:
  update the provided commands
TODO: add more commands

5. How it works                                       *togglepy-how* When you

TODO: format this section properly

When you open a Python file, and use the command `:ToggleIPythonTerm`, a
special toggleterm terminal is created that starts `ipython` by default. This
one will be remembered by togglepy.nvim, until you close its buffer, and used
for all REPL interactions. Most often, it might be the only toggleterm
terminal you use, in which case you can hide/unhide to it with `<C-\>`.
Single lines or selections can be send to the terminal with <F9>. Your file
can be executed with <F5>, which which will create terminal if it does not
exist yet, and runs your script with the ipython magic `%run your_script.py`.

TODO: check the switcher

By default the terminal will start in the Python environment as available at
the prompt where Neovim is started. You can also switch to another virtual
environment with `<leader>tv`, which uses telescope.nvim. For this to work,
the terminal needs to restart as well.

It is recommended to use the ipython REPL with the `autoreload` extension
enabled. This will basically ensure that modules are reloaded when you make
changes to them before execution. You can automate this by creating a file
`~/.ipython/profile_default/startup/mystartup.py` with the following
content:
>
 # ~/.ipython/profile_default/startup/mystartup.py
 get_ipython().run_line_magic("load_ext", "autoreload")
 get_ipython().run_line_magic("autoreload", "2")
<
There are some cases where autoreload does not work. So, unfortunately,
sometimes, you still have to restart the REPL. As togglepy.nvim provides 
the ipython REPL as is, so this is just how it works for now.

To get seemless debugging integration, we use the ipdab Python package, which
is a small wrapper around the standard ipdb/pdb debugger. Basically, use
`import ipdab; ipdab.set_trace()` instead of `import pdb; pdb.set_trace()`.
What now happens in the background is that a TCP server is started that
provides the Debug Adapter Protocol (DAP) interface. This is then used by
nvim-dap.nvim to connect to the debugging session. Unfortunately, pdb/ipdb are
blocking once you hit a breakpoint, i.e., control is given to the user or
process that controls the REPL. Therefore, the debugging session cannot be
fully controlled by nvim-dap.nvim. The way out with Neovim is to create
keymaps <F5>, <F10>, <F11> to that send `continue`, `next`, and `step`
commands to the REPL. This works because Neovim controls the teminal to which
the debugging control when it is blocking. When running your Python program in
a separate terminal, outside of Neovim, you can still connect the debugger to
it, but because Neovim does not control the terminal, you cannot send commands
to it and control the debugging session from within Neovim.









    

